### 递归函数

如果函数体直接或间接调用函数本身，则该函数称为递归函数

- 简化了原来的问题。递归函数通过逐步简化问题来表达计算

递归定义包含三个主要步骤：

**基本情况：** 您可以将基本情况视为最简单的函数输入的情况(**递归的停止条件**)

**递归调用一个较小的问题：**在我们当前问题所依赖的较小问题上调用该函数。 

**解决更大的问题：** 在第 2 步中，我们得到了一个较小问题的结果。 我们现在想要使用该结果来确定我们当前问题的结果应该是什么，这就是我们想要从当前函数调用中返回的结果。





1.  考虑这个递归阶乘函数：

**基本情况：**当 n 为 1 时，我们可以直接返回 1 的阶乘，也就是 1 

由于我们知道我们的基本情况 factorial(1) 会返回，我们可以根据 factorial(1) 计算 factorial(2)，然后根据 factorial(2) 计算 factorial(3)，依此类推

**递归调用一个较小的问题：** factorial(n) 取决于 factorial(n-1) 的结果

**解决更大的问题：** 在第 2 步中，我们得到了一个较小问题的结果。 我们现在想要使用该结果来确定我们当前问题的结果应该是什么，这就是我们想要从当前函数调用中返回的结果。

在我们的示例中，我们可以通过将较小问题 factorial(n-1)（代表 (n-1)！）的结果乘以 n（推理是 n！= n * (n- 1）！）

在这个例子中，我们相信 fact(n-1) 会正确计算 (n-1)！



#### 相互递归

当递归过程被划分为两个相互调用的函数时，我们称这两个函数是相互递归的。

例如，考虑以下非负整数的偶数和奇数定义：

- 一个数是偶数，即使它比奇数多一
- 如果一个数比偶数大 1，则该数为奇数
- 0 是偶数

使用这个定义，我们可以实现相互递归的函数来确定一个数是偶数还是奇数：

```python
def is_even(n):
    if n == 0:
        return True
    else:
        return is_odd(n-1)

def is_odd(n):
    if n == 0:
        return False
    else:
        return is_even(n-1)

result = is_even(4)
```

#### 树递归

**树递归：函数多次调用自身**

例如，考虑计算斐波那契数列，其中每个数都是前两个数之和。

```python
def fib(n):
    if n == 1:
        return 0
    if n == 2:
        return 1
    else:
        return fib(n-2) + fib(n-1)

result = fib(6)
```

#### 树递归的强大：探索不同的可能性





