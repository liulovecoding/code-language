## Sequences

-  序列不是特定内置类型或抽象数据表示的实例，而是在几种不同类型的数据之间共享的行为集合
- python中序列包括：元组，列表，字符串，range，迭代器，生成器。其中最重要的是列表



### 序列特性

**1.序列的加法与乘法**

模块**operator**中的 **add 函数(+)：**是将两个序列(**同类型的**)串联在一起形成一个新的序列，

**mul函数(*)：**接受一个序列和一个整数 k 来返回由原始序列的 k 次重复组成的序列

```python
>>> [2, 7] + digits * 2
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
a="ac"
>>>a=a*2+"b" 
acacb
>>>[]+[]
[]
>>> (1,2)*3+(3,4)
(1, 2, 1, 2, 1, 2, 3, 4)
>>>range(0,5)+range(5,7) #error:range不支持加法和乘法
```

 **2.运算符 in 和 not in:** 根据元素是否出现在序列中，其计算结果为 True 或 False。

```python
>>> digits
[1, 8, 2, 8]
>>> 2 in digits
True
>>> 1828 not in digits
True
>>>str
aaaab
>>>'a' in str
True
>>>tupl
(1, 2, 1, 2, 1, 2, 3, 4)
>>>"a" in tup1
False
>>>3 in range(0,3)
False
```

**3.切片:** 是原始序列的任何连续跨度，由一对整数指定。 与定义range一样，第一个整数表示切片的起始索引，第二个整数表示超出结束索引的一个。

**使用方括号， 冒号分隔起始索引和结束索引**（切片的结果还是序列）

```python
digits=[1, 8, 2, 8,7]
digits[:]==digits
>>>digits[:-1]    #等价于digits[:len(digits)-1]
[1,8,2,8]
digits[2:]==digits[2:len(digits)]
digits[1:2]==digits[1]
>>>digits[1:1]
[]
>>>digits[1:1]+=[1,2,3]
[1, 1, 2, 3, 8, 2, 8, 7]
>>>digits[len(digits):]+=[0,2,5]
[1, 1, 2, 3, 8, 2, 8, 7,0,2,5]
>>>range(0,3)[0:2]
range(0, 2)

digits[::-1] #反转序列
digits[::2]==digits[0:len(digits):2]==[1,2,7]#方括号里的2是步长
>>>digits[4::-1]#从digits[4]开始，步长为-1直到一端结束
[7, 8, 2, 8, 1]
```

**进一步阅读:** 切片符号允许各种特殊情况，例如负起始值、结束值和步长。 在 Dive Into Python 3 中名为切片列表的小节中有完整的描述

**4.索引：**在序列中索引为-1的元素是序列中最后一个元素

```python
>>>digits[-1] 
8
>>>str
abcde
>>>str[2]
c
>>>list1
[1,2,3,(2,3),[5,6,7]]
>>>list1[3][0] #如果序列的元素还是个序列，则可以嵌套索引
2
>>>list1[4][2]
7
```

**5.序列之间的转换**

```python
list( (1, 2, 3) ) == [1, 2, 3]
tuple([1, 2, 3]) == (1, 2, 3)
list(range(2, 10, 2)) == [2, 4, 6, 8]
list("ABCD") = ['A', 'B', 'C', 'D']
str(2)="2"
str(list("ABCD"))="ABCD"
>>>str(range(0,7)) #字符串和range不能直接转换
range(0,7) #字符串
```

**6.迭代：**序列是可迭代的

for 语句(处理顺序数据)可以遍历序列的元素并依次为每个元素执行一些计算，而不引入名称索引。

```python
for <name> in <expression>:
    <suite>
```

7.**序列拆包：** 这种将多个名称绑定到固定长度序列中的多个值的模式称为序列解包(**不包括字符串**)

程序中的一个常见模式是有一个元素序列，这些元素本身就是序列，但都是固定长度的。 for 语句可以在其标头中包含多个名称，以将每个元素序列“解包”到其各自的元素中

```python
>>>a,b,c=[1,2,3] #1
1 2 3
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
>>> same_count = 0
>>> for x, y in pairs:#2
    #将pairs中的每个元素解包成两个元素(因为是x，y两个元素)分别于x,y绑定
        if x == y:
            same_count = same_count + 1
>>> same_count
2
```

**8.聚合**：将序列中的所有值聚合为一个值。 列如：内置函数 sum、min 和 max，len 。

```python
#所有的序列
>>>sum(range(0,6))
 15
>>>len(range(0,6))
6
>>>min(range(0,6))
0
```

 

### 2.3.1  Lists

列表具有大量内置行为，以及表达这些行为的特定语法。 我们已经看到了列表字面值，其计算结果为列表实例，以及计算结果为列表中的值的元素选择表达式。

```python
>>> digits = [1, 8, 2, 8]#创建列表      
>>> len(digits)
4
>>>list(zip([1, 2, 5, 3], [9, 2, 6, 3, 10]))
[(1, 9), (2, 2), (5, 6), (3, 3)]
```

**任何类型的值都可以包含在列表中**

**列表的元素是可修改的**(修改的是引用变量的值)

```python
>>> pairs = [[10, 20], [30, 40],(2,3)]
>>> for x,y in digits:
        print(x,y)
10,20
30,40
2,3
>>> pairs[0][0]=1,paris[2]=(3,3)
>>>pairs
[[1,20],[20,40],(3,3)]
>>> list(zip([1, 2, 5, 3], [9, 2, 6, 3, 10]))
[(1, 9), (2, 2), (5, 6), (3, 3)]
>>> list(zip([1, 4, 7,	10], [2, 5, 8, 11],	[3, 6, 9, 12, 15]))
[(1, 2, 3), (4, 5, 6),	(7, 8, 9), (10, 11,	12)]

```

**通过列表创建新列表**

```python
list1=[1,2,3,4]
list3=list2[:]
list3=list(list1)
list2=list1 #指向同一个列表对象
#可以用id和is判断
```

**is :不要用于字符串和数值**，除非你有明确地理由否则别用

```python
if list1 is None:#用处1
    pass
if  type(list1) is type(list2):#用处2,类型比较
    pass
```



```python
list1 = [1,2,3]#创建一个对象
list2 = [1,2,3]#又创建一个
>>>id(list1)
2499849049216
>>>id(list2)
2499849167616
>>>identical = list1 is list2  #list1和list2指向的是同个对象时则返回True
False
>>>are_equal = list1 == list2 #llist1 和list2所指向地对象地内容相等时则返回True
True
# 相同的对象总是具有相同的值
```



**列表推导式** 

```python
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
>>> [x for x in odds if 25 % x == 0]
[1, 5]
```

上面的关键字for不是 for 语句的一部分，而是列表推导式的一部分，因为它包含在方括号中。 子表达式 x+1 被计算为 x 依次绑定到odds 的每个元素，并将结果值收集到一个列表中。

列表推导式的一般形式是：

```python
[<map expression> for <name> in <sequence expression> if <filter expression>]
```

为了计算列表推导式，Python 会计算 <sequence expression>，它必须返回一个可迭代的值。 然后，对于按顺序排列的每个元素，元素值绑定到 <name>，if <filter expression>为真，计算map expression表达式并把其值被收集到一个列表中

推导式的值是在新的局部框架中计算的，name 的值是未定义的。
在一个循环中给出一个循环的效果(**for语句可以有多个**)：

```python
>>> [ (a, b) for a in range(10, 13) for b in range(2) ] 
[(10, 0), (10, 1), (11, 0), (11, 1), (12, 0), (12, 1)]
```

**内置函数**：

append(x) 将元素x添加到列表尾部中

```python
s = [2, 3]
t = [5, 6]
>>>s.append(4) 
[2, 3, 4]
>>>s.append(t) 
[2, 3, 4, [5, 6]]
```

extend() 将一个列表中的所有元素添加到一个列表中

```python
s = [2, 3]
t = [5, 6]
>>>s.extend(4) 
error:4 is not an iterable(迭代)
>>>s.extend(t)  
[2, 3, 5, 6]
```

pop() 移除并返回最后一个元素

```python
s = [2, 3]
t = [5, 6]
>>>t = s.pop()
3
>>>name1=name.pop(x)#删除并返回name中索引为x的元素

```

remove() 删除与参数相等的第一个元素

```python
s = [6, 2, 4, 8, 4]
>>>s.remove(4)
None
>>>s
[6, 2, 8, 4]
```

insert(x,y)把元素y放到指定索引x的位置上，其后面的元素都后退

```
s=[1,2,3,4,5]
s.insert(3,10)
>>>s
[1,2,3,10,4,5]
```

count(list,x)计算x在list中出现的个数

```python
count(advice，"exam") == advice.count("exam") 
```



### 2.3.2  **range**

表示一个整数范围，它需要两个整数参数：第一个数字和一个超出所需范围内最后一个数字的数字

```python
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)
```

在range上调用列表构造函数会计算出与range具有相同元素的列表，以便可以轻松检查元素。

```python
>>> list(range(5, 8))
[5, 6, 7]
>>>print(range(0,3))
range(0, 3)
```

如果仅给出一个参数，则它被解释为超出从 0 开始的范围的最后一个值的一个。

```python
>>> list(range(4))
[0, 1, 2, 3]
```

range通常作为 for 标头中的表达式出现，以指定套件应执行的次数：如果套件中未使用名称，则常见约定是在 for 标头中使用单个下划线字符作为名称：

```python
>>> for _ in range(3):
        print('Go Bears!')
Go Bears!
Go Bears!
Go Bears!
```

就解释器而言，这个下划线只是环境中的另一个名称，但在程序员中具有约定俗成的含义，表明该名称不会出现在任何表达式中。



在修改上的理解：**元组，字符串类型的对象的值是不可改变的，因为一个不可变类型的对象的值是一个整体，没有部分的概念，也不可能修改这个整体的部分的值。可变对象的值可以看做是多种类型对象的组合，有部分的概念，因此可以修改部分**

```
t=(1,2,3)
#(1,2,3)是个整体，因此没法修改(1,2,3)中的1或者其他的值
list1=[1,3,2]
#[1,3,2]可以看成值为1，2，3的int类型的对象，因此有部分的概念，可以把1改成5
```



### **2.3.3 元组**

 -  用小括号将所有元素括起，可括可不括 
 -  相当于其元素不能修改的列表

```python
>>>t=5,7,9==(5,8,7)  
True
>>>print(t1,t)  #print函数总会显示由括号包围的元组
(5,8,7) (5,7,9)
>>>(x,y,z)=(5,6,7)  #创建三个变量并赋值
x=5,y=6,z=7
```



### 2.3.4 Strings

对于计算机科学而言，文本值可能比数值更重要。 例如，Python 程序是作为文本编写和存储的。 Python 中文本的原生数据类型称为字符串，对应于构造函数 str

- Python 没有单独的字符类型。 任何文本都是字符串，表示单个字符的字符串的长度为 1。

````python
str(2)="2"
#通过使用对象值作为参数调用构造函数str，可以从 Python 中的任何对象创建字符串 
#字符串的这一特性对于从各种类型的对象构造描述性字符串很有用。
````


