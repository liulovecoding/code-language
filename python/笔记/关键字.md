### 关键字

- 这两个关键字除非必要不然别用

一旦在子框架中修改父框架定义的变量(如：a=2)**(子框架没有变量与该变量指向相同对象)**,则python认为是在子框架中定义了一个变量a。而在子框架中，在定义子框架中的变量a之前使用了a,则判断为变量a未定义.

python会先保存所有变量的定义在相应的框架上

当在python中使用一个变量时，python会在当前框架搜索变量的定义，没找到在去其父框架中寻找，直到在某个框架中找到或者抛出该变量未定义(使用变量在定义变量之前也会这样)

```python
#案例1
def fun():
    a=1#无论a是什么类型的引用变量
    def fun():
        if a==1:#error:a is not defined
            print(a)#error:a is not defined
        else:
            a=2
            print(a) 
#案例2
x=1
def fun1():
    x=x+1 
    #先定义x，然后再计算x+1的时候，查找x,发现x还没有赋值   

#案例3
def fun():
     four =four+[1, 2, 3] #error:four未定义
     
four=[1,2,1,2]          
```

传参解决(只列案例1,3)

```python
def fun():
    a=1
    def fun(a=a)
        if a==1:
            print(a)
        else:
            a=2
            print(a)   
            

def fun(four):
     four = four+[1, 2, 3]            
```



**Nonlocal**：允许在框架中修改父框架**(不是全局框架)**中定义的变量**(子框架没有变量与该变量指向相同对象)**

在这个例子中，在子框架中声明子框架中使用的变量a不是子框架定义的变量，而是其父框架中定义的

```python
#案例1解决
def fun():
    a=1
    def fun():
        nonlocal a
        if a==1:
            print(a)
        else:
            a=2
            print(a)    
```

**global：**与Nonlocal大致相同，不过是用来在子框架修改**全局框架定义**的变量**(子框架没有变量与该变量指向相同对象)**

```python
#案例3解决
def fun():
     global four #不能用nonlocal，因为four是在全局框架中定义的，且(子框架没有变量与该变量指向相同对象)
     four =four+[1, 2, 3]
     
four=[1,2,1,2]  
```

